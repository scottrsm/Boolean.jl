var documenterSearchIndex = {"docs":
[{"location":"#Boolean.jl-Documentation","page":"Boolean.jl Documentation","title":"Boolean.jl Documentation","text":"","category":"section"},{"location":"","page":"Boolean.jl Documentation","title":"Boolean.jl Documentation","text":"CurrentModule = Boolean","category":"page"},{"location":"#Overview","page":"Boolean.jl Documentation","title":"Overview","text":"","category":"section"},{"location":"","page":"Boolean.jl Documentation","title":"Boolean.jl Documentation","text":"This module contains functions to compare Boolean functions. It does this by using a bit-vector representation and  comparing bits. The drawback with this representation is that it  grows exponentially with the number of variables in a boolean expression.","category":"page"},{"location":"","page":"Boolean.jl Documentation","title":"Boolean.jl Documentation","text":"High level constructors take an algebraic formula as the user representation of the logic function. This is then parsed and converted to a BitVector  representing the output of all possible inputs to its \"truth table\".","category":"page"},{"location":"","page":"Boolean.jl Documentation","title":"Boolean.jl Documentation","text":"Note: When parsing, the operator precedence is respected, with the  same precedence that Julia obeys. In particular, xor has the same precedence as or.","category":"page"},{"location":"","page":"Boolean.jl Documentation","title":"Boolean.jl Documentation","text":"There is an associated Jupyter notebook at src/BoolTest.ipynb.","category":"page"},{"location":"#Types","page":"Boolean.jl Documentation","title":"Types","text":"","category":"section"},{"location":"","page":"Boolean.jl Documentation","title":"Boolean.jl Documentation","text":"Op","category":"page"},{"location":"#Boolean.Op","page":"Boolean.jl Documentation","title":"Boolean.Op","text":"Define an operations type. Meant for the operators : +, :*, :⊕, :~ so that we can dispatch on them as types.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Boolean.jl Documentation","title":"Boolean.jl Documentation","text":"Blogic","category":"page"},{"location":"#Boolean.Blogic","page":"Boolean.jl Documentation","title":"Boolean.Blogic","text":"Structure used to represent a boolean formula involving variables  given by a single base string followed by a number.\n\nNote: The formula to be represented must only contain the  operators: \n\n~ – The NOT operator.\n* – The AND operator.\n+ – The OR operator.\n⊕ – The XOR operator.\n\nThese operators are left associative and the operator precedence from  highest to lowest is:\n\n~\n*\n+, xor\n\nIn practice, one uses a higher level constructor (create_bool_rep)  or use the macro @bfunc the inner constructor.\n\nFields\n\nformula :: String    – The string representation of the formula.\nvar     :: String    – The base name of the logical variables.\nsize    :: Int64     – The number of variables in the formula.\nval     :: BitVector – The bit vector representing the formula.                            It essentially expresses the values of all possible inputs.  \n\nConstructors\n\nBlogic(form::String, v::String, value::BitVector)\n\nExamples\n\njulia> Blogic(\"(z1 + z2) * z3\", \"z\", BitVector([0, 0, 0, 0, 0, 1, 1, 1]))\n\nFormula    = (z1 + z2) * z3\nVariable   = z\nSize       = 3\nBit vector = Bool[0, 0, 0, 0, 0, 1, 1, 1]\n\nThis is the logic (boolean) formula that ORs z1 and z2,          then ANDs that with z3.\n\n\n\n\n\n","category":"type"},{"location":"#Alternative-Blogic-Constructor","page":"Boolean.jl Documentation","title":"Alternative Blogic Constructor","text":"","category":"section"},{"location":"","page":"Boolean.jl Documentation","title":"Boolean.jl Documentation","text":"create_bool_rep","category":"page"},{"location":"#Boolean.create_bool_rep","page":"Boolean.jl Documentation","title":"Boolean.create_bool_rep","text":"create_bool_rep(s, simplify=false)\n\nTurn boolean formula into a BitVector representation, Blogic.\n\nThis is done by the following procedure:\n\nDetermine the underlying base variable used in the formula.\nParse the formula into an expression, Expr.\nOptionally simplify the logical expression.\nWalk the expression tree creating a new tree with Julia    mathematical operators substituted for user operators.\nEvaluate the expression to create a BitVector.\n\nArguments\n\ns :: String      – A logical string.\nsimplify=false :: Bool – If true simplify the logical expression before                        creating the BitVector.\n\nExamples\n\njulia> create_bool_rep(\"(z1 + z2) * z3\")\n\nFormula    = (z1 + z2) * z3\nVariable   = z\nSize       = 3\nBit vector = Bool[0, 0, 0, 0, 0, 1, 1, 1]\n\nReturn\n\n::Blogic – Type representing the logical expression.\n\n\n\n\n\n","category":"function"},{"location":"#High-Level-Module-Functions","page":"Boolean.jl Documentation","title":"High Level Module Functions","text":"","category":"section"},{"location":"","page":"Boolean.jl Documentation","title":"Boolean.jl Documentation","text":"@bfunc","category":"page"},{"location":"#Boolean.@bfunc","page":"Boolean.jl Documentation","title":"Boolean.@bfunc","text":"bfunc(x)\n\nA macro to create a Blogic function in a syntactically clean way. This macro determes if an input expression is a valid formula and creates the associated \"truth table\" BitVectors based on the number of variables in the formula. The function that does this is init_logic which modifies global variables.\n\nExample\n\njulia> @bfunc((z1 + z2) * z3)\n\nFormula    = (z1 + z2) * z3\nVariable   = z\nSize       = 3\nBit vector = Bool[0, 0, 0, 0, 0, 1, 1, 1]\n\n\n\n\n\n","category":"macro"},{"location":"","page":"Boolean.jl Documentation","title":"Boolean.jl Documentation","text":"(Blogic)(::Vararg{Int64})","category":"page"},{"location":"#Boolean.Blogic-Tuple{Vararg{Int64}}","page":"Boolean.jl Documentation","title":"Boolean.Blogic","text":"(Blogic)(xs::Vararg{Int64})\n\nUses the structure Blogic as a Boolean function. \n\nArguments\n\nxm :: Vararg{Int64}  – A Varargs structure representing inputs to the                          Blogic function, f.\n\nReturn\n\n::Bool\n\n\n\n\n\n","category":"method"},{"location":"","page":"Boolean.jl Documentation","title":"Boolean.jl Documentation","text":"(Blogic)(::Matrix{Int64})","category":"page"},{"location":"#Boolean.Blogic-Tuple{Matrix{Int64}}","page":"Boolean.jl Documentation","title":"Boolean.Blogic","text":"(Blogic)(xm::Matrix{Int64})\n\nUses the structure Blogic as a Boolean function. \n\nArguments\n\nxm :: Matrix{Int64}  – A matrix of size M, N representing M sets of inputs                           to the function, f, which takes N variables.\n\nReturn\n\n::BitVector of length M.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Boolean.jl Documentation","title":"Boolean.jl Documentation","text":"isEquiv(f1::String, f2::String)","category":"page"},{"location":"#Boolean.isEquiv-Tuple{String, String}","page":"Boolean.jl Documentation","title":"Boolean.isEquiv","text":"isEquiv(f1::String, f2::String)\n\nDetermines if two logical functions are equivalent when represented as strings.\n\nArguments\n\nf1 :: String – Formula 1.\nf2 :: String – Formula 2.\n\nReturn\n\n::Bool – true if the formulas are equivalent; false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Boolean.jl Documentation","title":"Boolean.jl Documentation","text":"isEquiv(f1::Blogic, f2::Blogic)","category":"page"},{"location":"#Boolean.isEquiv-Tuple{Blogic, Blogic}","page":"Boolean.jl Documentation","title":"Boolean.isEquiv","text":"isEquiv(f1::Blogic, f2::Blogic)\n\nDetermines if two logical functions are equivalent when represented as Blogic structures.\n\nArguments\n\nf1 :: Blogic – Formula 1.\nf2 :: Blogic – Formula 2.\n\nReturn\n\n::Bool – true if the formulas are equivalent; false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#Base-Overloaded-Functions","page":"Boolean.jl Documentation","title":"Base Overloaded Functions","text":"","category":"section"},{"location":"","page":"Boolean.jl Documentation","title":"Boolean.jl Documentation","text":"Used to show Blogic structures and compare Symbols with Expressions.","category":"page"},{"location":"","page":"Boolean.jl Documentation","title":"Boolean.jl Documentation","text":"Base.show(::IO, ::Blogic)","category":"page"},{"location":"#Base.show-Tuple{IO, Blogic}","page":"Boolean.jl Documentation","title":"Base.show","text":"Show the Blogic structure.\nParams:\nio: IO handle.\nx : Blogic structure.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Boolean.jl Documentation","title":"Boolean.jl Documentation","text":"Base.show(::IO, ::BitMatrix)","category":"page"},{"location":"#Base.show-Tuple{IO, BitMatrix}","page":"Boolean.jl Documentation","title":"Base.show","text":"Show a BitMatrix.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Boolean.jl Documentation","title":"Boolean.jl Documentation","text":"Base.isless(::Int64, ::Symbol)","category":"page"},{"location":"#Base.isless-Tuple{Int64, Symbol}","page":"Boolean.jl Documentation","title":"Base.isless","text":"Base.isless(i1::Int64, s2::Symbol)\n\nCompare an Int64 with a Symbol.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Boolean.jl Documentation","title":"Boolean.jl Documentation","text":"Base.isless(::Int64, ::Expr)","category":"page"},{"location":"#Base.isless-Tuple{Int64, Expr}","page":"Boolean.jl Documentation","title":"Base.isless","text":"Base.isless(i1::Int64, e2::Expr)\n\nCompare an Int64 with an Expr.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Boolean.jl Documentation","title":"Boolean.jl Documentation","text":"Base.isless(::Symbol, ::Expr)","category":"page"},{"location":"#Base.isless-Tuple{Symbol, Expr}","page":"Boolean.jl Documentation","title":"Base.isless","text":"Base.isless(s1::Symbol, e2::Expr)\n\nCompare an Symbol with an Expr.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Boolean.jl Documentation","title":"Boolean.jl Documentation","text":"Base.isless(::Expr, ::Expr)","category":"page"},{"location":"#Base.isless-Tuple{Expr, Expr}","page":"Boolean.jl Documentation","title":"Base.isless","text":"Base.isless(e1::Expr, e2::Expr)\n\nCompare two Julia Expr expressions.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Boolean.jl Documentation","title":"Boolean.jl Documentation","text":"Base.:(==)(::Blogic, ::Blogic)","category":"page"},{"location":"#Base.:==-Tuple{Blogic, Blogic}","page":"Boolean.jl Documentation","title":"Base.:==","text":"Base.:(==)\n\nOverload the equality function for structures of Blogic type.\n\n\n\n\n\n","category":"method"},{"location":"#Low-Level-Functions","page":"Boolean.jl Documentation","title":"Low Level Functions","text":"","category":"section"},{"location":"","page":"Boolean.jl Documentation","title":"Boolean.jl Documentation","text":"logicCount","category":"page"},{"location":"#Boolean.logicCount","page":"Boolean.jl Documentation","title":"Boolean.logicCount","text":"logicCount(f)\n\nCount the number of true values possible in a given formula.\n\nArguments\n\nf :: Blogic – A logic formula\n\nReturn\n\nThe number of true values that are possible with this formula.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Boolean.jl Documentation","title":"Boolean.jl Documentation","text":"nonZero","category":"page"},{"location":"#Boolean.nonZero","page":"Boolean.jl Documentation","title":"Boolean.nonZero","text":"nonZero(f, head=1)\n\nGet up to head inputs that generate true values for a logic function, f.\n\nArguments\n\nf :: Blogic – A logic formula.\n\nOptional Arguments\n\nhead=1 :: Int64  – The maximum number of inputs to consider.\n\nReturn\n\nA list of up to head input values that will give the  logic function, f, a value of true.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Boolean.jl Documentation","title":"Boolean.jl Documentation","text":"get_non_zero_inputs","category":"page"},{"location":"#Boolean.get_non_zero_inputs","page":"Boolean.jl Documentation","title":"Boolean.get_non_zero_inputs","text":"get_non_zero_inputs(v, n[; num=1])\n\nGet num inputs that generate true values for a logic function. v is a boolean vector that indicates which elements of the truth table yield a value of true.\n\nArguments\n\nv   :: BitVector – A bit vector representing true and false values.\nn   :: Int64     – Describes the length of the truth table column: 2^n.\n\nOptional Arguments\n\nnum :: Int64     – The desired number of inputs that generate truth values.\n\nReturns\n\n::Union{BitMatrix, Nothing} – Input values that generate truth values for the current function.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Boolean.jl Documentation","title":"Boolean.jl Documentation","text":"bool_var_rep","category":"page"},{"location":"#Boolean.bool_var_rep","page":"Boolean.jl Documentation","title":"Boolean.bool_var_rep","text":"bool_var_rep(n)\n\nGenerate the boolean bit vectors necessary to represent a logic  formula of n variables. \n\nEssentially, generate the truth table  of each of the variables collectively as a BitArray.\n\nArguments\n\nn : Number of logical variables.\n\nReturn\n\n::BitArray – The bit representation of all of the logical variables.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Boolean.jl Documentation","title":"Boolean.jl Documentation","text":"init_logic","category":"page"},{"location":"#Boolean.init_logic","page":"Boolean.jl Documentation","title":"Boolean.init_logic","text":"init_logic\n\nThis sets two global variables, the size of the boolean vectors and  the other the Bitarray representations of the variables.\n\nArguments\n\nn :: Int64 – The number of boolean variables used in the formulas\n\nthis module will consider.\n\nReturn\n\nNothing\n\n\n\n\n\n","category":"function"},{"location":"","page":"Boolean.jl Documentation","title":"Boolean.jl Documentation","text":"parseLogic","category":"page"},{"location":"#Boolean.parseLogic","page":"Boolean.jl Documentation","title":"Boolean.parseLogic","text":"parseLogic\n\nThis function creates a parse tree for a boolean expression. The Julia function Meta.parse does this – for the most part. One of the nice features of this parser is that it collapses expressions like (+ (x1 (+ x2 (+x3 x4)))) to (+ x1 x2 x3 x4). It does the same for '*'. However, it does not do so for  'xor'. We adjust this parse tree from Meta.parse so that it  does have this property for 'xor'.\n\nArguments\n\nexpr::String – A logic formula\n\nReturn\n\nA parse tree with variable string names replaced with symbols.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Boolean.jl Documentation","title":"Boolean.jl Documentation","text":"modifyLogicExpr!","category":"page"},{"location":"#Boolean.modifyLogicExpr!","page":"Boolean.jl Documentation","title":"Boolean.modifyLogicExpr!","text":"modifyLogicExpr!(e)\n\nThe default rule for modifying a logic expression is to do nothing.\n\n\n\n\n\nmodifyLogicExpr!(e::Expr)\n\nWalk an expression tree, converting variable names and operators to Julia operators and variables into BitVector representations.\n\nArguments\n\ne :: Expr – An expression.\n\nReturn\n\n::Expr – A logic expression.\n\n\n\n\n\nmodifyLogicExpr!(e::Symbol)\n\nIf e is a Symbol, it should be a variable of the form r\"[a-zA-Z]+[0-9]+\".\n\nThe code splits the name off and uses the number to look up the      BitVector representation.     Otherwise, it is assumed to be an operator symbol and it is then      mapped to the appropriate Julia operator.\n\nNOTE: This will work even if one makes a mistake and uses              x3, or y3, the bit vector for the              third \"variable\" will be used.\n\nArguments\n\ne :: Symbol – An variable or operator.\n\nReturn\n\n::Expr – A logic expression.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Boolean.jl Documentation","title":"Boolean.jl Documentation","text":"simplifyLogic","category":"page"},{"location":"#Boolean.simplifyLogic","page":"Boolean.jl Documentation","title":"Boolean.simplifyLogic","text":"simplifyLogic(e)\n\nSimplify a logical expression.\n\nThis function calls a number of specialized variations of this function  to deal with different logical operators.\n\nArguments\n\ne :: Expr – Logic expression.\n\nReturn\n\n::Expr – Simplified logic expression.\n\n\n\n\n\nsimplifyLogic(::Op{:~}, xargs::Any)\n\nsimplifyLogic for the NOT operator.\n\n\n\n\n\nsimplifyLogic(::Op{:+}, xargs::Vector{Any})\n\nsimplifLogic for the OR operator.\n\n\n\n\n\nsimplifyLogic(::Op{:*}, xargs::Vector{Any})\n\nsimplifyLogic for the AND operator.\n\n\n\n\n\nsimplifyLogic(::Op{:⊕}, xargs::Vector{Any})\n\nsimplifyLogic for the XOR operator.\n\n\n\n\n\nsimplifyLogic(e::Union{Int64, Symbol})\n\nsimplifyLogic for the irreducible cases: A number or a symbol.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Boolean.jl Documentation","title":"Boolean.jl Documentation","text":"rle","category":"page"},{"location":"#Boolean.rle","page":"Boolean.jl Documentation","title":"Boolean.rle","text":"rle(xs)\n\nPerforms a R(un) L(ength) E(ncoding) on an array,  grouping like values into arrays.\n\nThe values are assumed to be sorted.\n\nArguments\n\nxs :: Vector{T} – An array that is sortable.\n\nReturn\n\n::Vector{Tuple{T, Int64}} – A Vector of pairs of the form: (T, Int64) representing values from xs and the number of their occurrences.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Boolean.jl Documentation","title":"Boolean.jl Documentation","text":"redux","category":"page"},{"location":"#Boolean.redux","page":"Boolean.jl Documentation","title":"Boolean.redux","text":"redux(::Op{T}, Tuple{S, Int64})\n\nReduce a pair consisting of an expression and its count to just  an expression. \n\nThe default case is to just return the expression.\n\nArguments\n\n::Op{T}                    – An operator type.\npair :: Tuple{Expr, Int64} – Expression and its count.\n\nReturn\n\n::Expr – Simplified logic expression.\n\n\n\n\n\nredux(::Opt{:⊕}, pair::Tuple{Expr, Int64})\n\nReduce a pair consisting of an expression and its count to just  an expression. \n\nFor an XOR expression, we know that only the expression  remains or the value is 0.\n\nArguments\n\n:::Opt{:⊕}                 – An operator type.\npair :: Tuple{Expr, Int64} – Expression and its count.\n\nReturn\n\n::Expr – Simplified logic expression.\n\n\n\n\n\n","category":"function"},{"location":"#Index","page":"Boolean.jl Documentation","title":"Index","text":"","category":"section"},{"location":"","page":"Boolean.jl Documentation","title":"Boolean.jl Documentation","text":"","category":"page"}]
}
